$$
{\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{基}\text{本}\text{概}\text{念}{ \left\{ {\begin{array}{*{20}{l}}
{\text{稳}\text{定}\text{性}}\\
{\text{衡}\text{量}\text{标}\text{准}\text{：}\text{时}\text{、}\text{空}\text{复}\text{杂}\text{度}}
\end{array}}\right. }}\\
{\text{内}\text{部}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\begin{array}{*{20}{l}}
{\text{插}\text{入}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{直}\text{接}\text{插}\text{入}\text{排}\text{序}}\\
{\text{折}\text{半}\text{插}\text{入}\text{排}\text{序}}\\
{\text{希}\text{尔}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{交}\text{换}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{冒}\text{泡}\text{排}\text{序}}\\
{\text{快}\text{速}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{选}\text{择}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{简}\text{单}\text{选}\text{择}\text{排}\text{序}}\\
{\text{堆}\text{排}\text{序}}
\end{array}}\right. }}
\end{array}}\\
{\text{并}\text{归}\text{排}\text{序}}\\
{\text{基}\text{数}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{外}\text{部}\text{排}\text{序}\text{—}\text{—}\text{多}\text{路}\text{并}\text{归}\text{排}\text{序}}
\end{array}}\right. }}
$$

## 一、插入排序

&emsp;&emsp;插入排序的思路：将数据列分成两组，一组是已排序的序列A，另一组是未排序的序列B。遍历B将B中的元素插入到A中，从而使序列有序。

### 1.1 直接插入排序
&emsp;&emsp;将序列分成两部分，从头到尾遍历序列完成排序。现在我们有：

- 序列L[0, n-1]
- 有序序列A[0, i-1]
- 无序序列B[i, n-1]

算法简述：

1. 选择B的头部，**顺序查找**找到其在A中插入的位置k
2. 将B插入到L\[k\]；向后移动L[k, i-1]，到L[k+1, i]。
3. 重复直到遍历完数组

&emsp;&emsp;算法分析：

- 空间效率：复杂度O(1)
- 时间效率：在排序过程中，向A中指向了n-1次插入操作。在最好情况下，只用插入不用移动，时间复杂度为O(n)；在最坏情况下，每次插入都移动i+1次，移动的总次数为：${\mathop{ \sum }\limits_{{i=1}}^{{n}}{ \left( i+1 \right) }}$。注意，这里下标i从1开始，数组的1号位置下标为0。在平均情况下，时间复杂度约为n<sup>2</sup> / 4。因此其时间复杂度为O(n<sup>2</sup>)。
- 稳定性：因为是从后向前比较（或是反之），所以不用担心相同元素的相对位置发生变化，之间插入排序是一个稳定的排序算法。
- 适用性：顺序表、链表。

### 1.2 折半插入排序
&emsp;&emsp;和直接插入排序一样，只是查找的过程变为折半查找。

### 1.3 希尔排序
&emsp;&emsp;算法描述：

0. 初始化 di = n / 2;
1. 选取步长d<sub>i</sub>，将序列分成间隔d<sub>i</sub>的n/d<sub>i</sub>组;
2. 在组内进行插入排序;
3. 令d<sub>i+1</sub> = d<sub>i</sub> / 2;
4. 重复(1, 4)步直到di == 1;

&emsp;&emsp;算法分析：

- 空间效率：复杂度O(1)。
- 时间效率：平均情况下为O(n<sup>1.3</sup>)，最坏情况下为O(n<sup>2</sup>)
- 稳定性：分组的原因可能会改变相同元素的相对位置，其是不稳定的排序方法。
- 适用性：顺序表。

## 二、交换排序
### 2.1 冒泡排序
&emsp;&emsp;大部分人学习的第一个排序方法，按照排序准则将“最大/小”的元素放入序列的首部或末尾。

```cpp
void BubbleSort(std::vector<ElementType>& Seq)
{
    // i表示第i次排序，此时针对第i个元素，比较它和序列中剩下元素的大小，选出最小的放入第i个位置（交换ij的位置）
    for (int i = 0; i < Seq.size(); ++i)
    {
        // 用于判断本次(i)是否发生了交换
        bool flag { false };
        for (int j = i; j < Seq.size(); ++j)
        {
            // 这里使用 < 作为排序准则
            if (Seq[i] < Seq[j])
            {
                swap(Seq[i], Seq[j]);
                flag = true;
            }
        }

        // 如果没有发生交换，则说明序列已经有序
        if (!flag)   return;
    }

    return;
}
```

&emsp;&emsp;算法分析：

- 空间效率：swap需要使用一个中间变量，复杂度O(1)。
- 时间效率：当序列有序时，比较n-1次、移动0次，从而最好情况下的时间复杂度为O(n)；当序列逆序时，比较：Sigma<sub>i=1</sub><sup>n-1</sup>(n-i) = n(n-1) / 2、移动Sigma<sub>i=1</sub><sup>n-1</sup>3(n-i) = 3n(n-1) / 2，从而最坏情况下时间复杂度为O(n<sup>2</sup>)。
- 稳定性：不改变相同元素的相对位置，是稳定的排序方法。

### 2.2 快速排序
&emsp;&emsp;下面我们通过一个实例来说明，考虑序列：49、38、65、97、76、13、27、49。这里使用“&lt;”作为排序准则。
[caption width="1041" align="aligncenter"]<img src="https://cdn.swordofmorning.com/SwordofMorning/Article%20Images/pgexamDataStructer/09/QuickSort.drawio.png" width="1041" height="2089" alt="图1" class="size-full" /> 图1：快排实例[/caption]

```cpp
void QuickSort(std::vector<ElemType>& seq, int head, int tail)
{
    if (head < tail)    // 递归跳出条件
    {
        // 划分序列
        int pos = Partition(seq, head, tail);

        // 子序列快排
        QuickSort(seq, head, pos - 1);
        QuickSort(seq, pos + 1, tail);
    }
}

// 序列分组
int Partition(std::vector<ElemType>& seq, int head, int tail)
{
    OP op;
    while (head < tail)
    {
        // 移动尾部指针，意图找到!(*head op *tail)
        while (head < tail && op(seq[head], seq[tail])) --tail;
        swap(seq[head], seq[tail]);
        // 移动首部指针，意图找到!(*head op *tail)
        while (head < tail && op(seq[head], seq[tail])) ++head;
        swap(seq[head], seq[tail]);
    }
    return head;
}

// 排序准则，这里使用<=
class OP
{
public:
    bool operator()(ElemType A, ElemType B)
    {
        return A <= B;
    }
}
```

&emsp;&emsp;算法分析：

- 空间效率：递归需要借助一个工作栈完成，其容量与递归深度一致，最好情况下为O(log<sub>2</sub>n)，最坏情况下为O(n-1)，平均为O(log<sub>2</sub>n)。
- 时间效率：O(n<sup>2</sup>)。
- 稳定性：子序列以及排序准则（<或<=一类）的选择，其不稳定。