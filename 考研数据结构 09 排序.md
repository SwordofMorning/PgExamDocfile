$$
{\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{基}\text{本}\text{概}\text{念}{ \left\{ {\begin{array}{*{20}{l}}
{\text{稳}\text{定}\text{性}}\\
{\text{衡}\text{量}\text{标}\text{准}\text{：}\text{时}\text{、}\text{空}\text{复}\text{杂}\text{度}}
\end{array}}\right. }}\\
{\text{内}\text{部}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\begin{array}{*{20}{l}}
{\text{插}\text{入}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{直}\text{接}\text{插}\text{入}\text{排}\text{序}}\\
{\text{折}\text{半}\text{插}\text{入}\text{排}\text{序}}\\
{\text{希}\text{尔}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{交}\text{换}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{冒}\text{泡}\text{排}\text{序}}\\
{\text{快}\text{速}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{选}\text{择}\text{排}\text{序}{ \left\{ {\begin{array}{*{20}{l}}
{\text{简}\text{单}\text{选}\text{择}\text{排}\text{序}}\\
{\text{堆}\text{排}\text{序}}
\end{array}}\right. }}
\end{array}}\\
{\text{并}\text{归}\text{排}\text{序}}\\
{\text{基}\text{数}\text{排}\text{序}}
\end{array}}\right. }}\\
{\text{外}\text{部}\text{排}\text{序}\text{—}\text{—}\text{多}\text{路}\text{并}\text{归}\text{排}\text{序}}
\end{array}}\right. }}
$$

## 一、插入排序

&emsp;&emsp;插入排序的思路：将数据列分成两组，一组是已排序的序列A，另一组是未排序的序列B。遍历B将B中的元素插入到A中，从而使序列有序。

### 1.1 直接插入排序
&emsp;&emsp;将序列分成两部分，从头到尾遍历序列完成排序。现在我们有：

- 序列L[0, n-1]
- 有序序列A[0, i-1]
- 无序序列B[i, n-1]

算法简述：

1. 选择B的头部，**顺序查找**找到其在A中插入的位置k
2. 将B插入到L\[k\]；向后移动L[k, i-1]，到L[k+1, i]。
3. 重复直到遍历完数组

&emsp;&emsp;算法分析：

- 空间效率：复杂度O(1)
- 时间效率：在排序过程中，向A中指向了n-1次插入操作。在最好情况下，只用插入不用移动，时间复杂度为O(n)；在最坏情况下，每次插入都移动i+1次，移动的总次数为：${\mathop{ \sum }\limits_{{i=1}}^{{n}}{ \left( i+1 \right) }}$。注意，这里下标i从1开始，数组的1号位置下标为0。在平均情况下，时间复杂度约为n<sup>2</sup> / 4。因此其时间复杂度为O(n<sup>2</sup>)。
- 稳定性：因为是从后向前比较（或是反之），所以不用担心相同元素的相对位置发生变化，之间插入排序是一个稳定的排序算法。
- 适用性：顺序表、链表。

### 1.2 折半插入排序
&emsp;&emsp;和直接插入排序一样，只是查找的过程变为折半查找。

### 1.3 希尔排序
&emsp;&emsp;算法描述：

0. 初始化 di = n / 2;
1. 选取步长d<sub>i</sub>，将序列分成间隔d<sub>i</sub>的n/d<sub>i</sub>组;
2. 在组内进行插入排序;
3. 令d<sub>i+1</sub> = d<sub>i</sub> / 2;
4. 重复(1, 4)步直到di == 1;

&emsp;&emsp;算法分析：

- 空间效率：复杂度O(1)。
- 时间效率：平均情况下为O(n<sup>1.3</sup>)，最坏情况下为O(n<sup>2</sup>)
- 稳定性：分组的原因可能会改变相同元素的相对位置，其是不稳定的排序方法。
- 适用性：顺序表。

